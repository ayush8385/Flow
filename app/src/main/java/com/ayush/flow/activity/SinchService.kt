package com.ayush.flow.activityimport android.R.*import android.app.*import android.app.ActivityManager.RunningAppProcessInfoimport android.content.Contextimport android.content.Intentimport android.os.*import android.util.Logimport android.widget.Toastimport androidx.core.app.NotificationCompatimport com.ayush.flow.activity.Dashboard.Companion.CHANNEL_IDimport com.ayush.flow.database.ChatViewModelimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.database.DataSnapshotimport com.google.firebase.database.DatabaseErrorimport com.google.firebase.database.FirebaseDatabaseimport com.google.firebase.database.ValueEventListenerimport com.sinch.android.rtc.*import com.sinch.android.rtc.calling.Callimport com.sinch.android.rtc.calling.CallClientimport com.sinch.android.rtc.calling.CallClientListenerimport com.sinch.android.rtc.calling.CallListenerimport java.util.*class SinchService : Service(){    private var audioPlayer: AudioPlayer? = null    private val mSinchServiceInterface: SinchServiceInterface = SinchServiceInterface()    private var mSinchClient: SinchClient? = null    var userName: String? = null        private set    private var mListener: StartFailedListener? = null    override fun onCreate() {        val firebaseUser= FirebaseAuth.getInstance().currentUser        start(firebaseUser!!.uid)        super.onCreate()    }    override fun onDestroy() {        if (mSinchClient != null && mSinchClient!!.isStarted) {            mSinchClient!!.terminate()        }        super.onDestroy()    }    private fun start(userName: String) {        if (mSinchClient == null) {            this.userName = userName            mSinchClient =                Sinch.getSinchClientBuilder().context(getApplicationContext()).userId(userName)                    .applicationKey(APP_KEY)                    .applicationSecret(APP_SECRET)                    .environmentHost(ENVIRONMENT).build()            mSinchClient!!.setSupportCalling(true)            mSinchClient!!.setSupportManagedPush(true)            mSinchClient!!.startListeningOnActiveConnection()            mSinchClient!!.addSinchClientListener(MySinchClientListener())            mSinchClient!!.getCallClient().addCallClientListener(SinchCallClientListener())            mSinchClient!!.setPushNotificationDisplayName(userName)            mSinchClient!!.start()            Log.d("sinching..........","Sinch Started")            Toast.makeText(applicationContext,"Sinch Staryed",Toast.LENGTH_SHORT).show()        }    }    private fun createClientIfNecessary() {        if (mSinchClient != null) return        start(FirebaseAuth.getInstance().currentUser!!.uid)    }    private fun stop() {        if (mSinchClient != null) {            mSinchClient!!.terminate()            mSinchClient = null        }    }    private val isStarted: Boolean        private get() = mSinchClient != null && mSinchClient!!.isStarted    override fun onBind(intent: Intent?): IBinder {        return mSinchServiceInterface    }    inner class SinchServiceInterface : Binder() {        fun callPhoneNumber(phoneNumber: String?): Call {            return mSinchClient!!.callClient.callPhoneNumber(phoneNumber)        }        fun callUser(userId: String?): Call {            return mSinchClient!!.callClient.callUser(userId)        }        fun callUser(userId: String?, headers: Map<String?, String?>?): Call {            return mSinchClient!!.callClient.callUser(userId, headers)        }        val isStarted: Boolean            get() = this@SinchService.isStarted        fun startClient(userName: String) {            start(userName)        }        fun stopClient() {            stop()        }        fun setStartListener(listener: StartFailedListener?) {            mListener = listener        }        fun getCall(callId: String?): Call {            return mSinchClient!!.callClient.getCall(callId)        }        fun muteCall() {            mSinchClient!!.audioController.mute()        }        fun unmuteCall() {            mSinchClient!!.audioController.unmute()        }        fun onSpeaker() {            mSinchClient!!.audioController.enableSpeaker()        }        fun offSpeaker() {            mSinchClient!!.audioController.disableSpeaker()        }        fun relayRemotePushNotificationPayload(payload: MutableMap<String, String>?): NotificationResult? {            createClientIfNecessary()            return mSinchClient!!.relayRemotePushNotificationPayload(payload)        }//        fun relayRemotePushNotificationPayload(payload: Map<*, *>?): NotificationResult? {//            if (mSinchClient == null && !mUserId.isEmpty()) {//                start(mUserId)//            } else if (mSinchClient == null && mUserId.isEmpty()) {//                Log.e(//                    TAG,//                    "Can't start a SinchClient as no username is available, unable to relay push."//                )//                return null//            }//            return mSinchClient.relayRemotePushNotificationPayload(payload)//        }    }    interface StartFailedListener {        fun onStartFailed(error: SinchError?)        fun onStarted()    }    private inner class MySinchClientListener : SinchClientListener {        override fun onClientFailed(client: SinchClient, error: SinchError) {            if (mListener != null) {                mListener!!.onStartFailed(error)            }            mSinchClient!!.terminate()            mSinchClient = null        }        override fun onClientStarted(client: SinchClient) {            Log.d(TAG, "SinchClient started")            if (mListener != null) {                mListener!!.onStarted()            }        }        override fun onClientStopped(client: SinchClient) {            Log.d(TAG, "SinchClient stopped")        }        override fun onLogMessage(level: Int, area: String, message: String) {            when (level) {                Log.DEBUG -> Log.d(area, message)                Log.ERROR -> Log.e(area, message)                Log.INFO -> Log.i(area, message)                Log.VERBOSE -> Log.v(area, message)                Log.WARN -> Log.w(area, message)            }        }        override fun onRegistrationCredentialsRequired(client: SinchClient, clientRegistration: ClientRegistration) {        }    }    inner class SinchCallClientListener : CallClientListener {        override fun onIncomingCall(callClient: CallClient?, call: Call) {//            Log.d(TAG, "Incoming call")            val intent = Intent(this@SinchService, Calling::class.java)            intent.putExtra(CALL_ID, call.callId)            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)            //startActivity(intent)            audioPlayer = AudioPlayer(applicationContext)            call.addCallListener(SinchCallListener())            val inForeground: Boolean = isAppOnForeground(applicationContext)            if (inForeground) {                this@SinchService.startActivity(intent)            }            else {                if (!audioPlayer!!.isPlayedRingtone()) {                    audioPlayer!!.playRingtone()                }                (Objects.requireNonNull(getSystemService(NOTIFICATION_SERVICE)) as NotificationManager).notify(1,createIncomingCallNotification(call.remoteUserId, intent)                )            }        }        private fun isAppOnForeground(context: Context): Boolean {            val activityManager =                context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager            var appProcesses: List<RunningAppProcessInfo>? = null            if (activityManager != null) {                appProcesses = activityManager.runningAppProcesses            }            if (appProcesses == null) {                return false            }            val packageName: String = context.getPackageName()            for (appProcess in appProcesses) {                if (appProcess.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND && appProcess.processName == packageName) {                    return true                }            }            return false        }        private fun getPendingIntent(intent: Intent, action: String): PendingIntent? {            intent.action = action            return PendingIntent.getActivity(                applicationContext,                111,                intent,                PendingIntent.FLAG_UPDATE_CURRENT            )        }        private fun createIncomingCallNotification(userId: String, fullScreenIntent: Intent): Notification? {            val pendingIntent = PendingIntent.getActivity(                applicationContext,                112,                fullScreenIntent,                PendingIntent.FLAG_UPDATE_CURRENT            )            val builder: NotificationCompat.Builder =                NotificationCompat.Builder(applicationContext, CHANNEL_ID)                    .setContentTitle("Incoming Audio call")                    .setSmallIcon(com.ayush.flow.R.drawable.flow)                    .setPriority(NotificationCompat.PRIORITY_MAX)                    .setContentIntent(pendingIntent)                    .setFullScreenIntent(pendingIntent, true)                    .addAction(                        R.drawable.common_google_signin_btn_icon_dark,                        "Answer",                        getPendingIntent(fullScreenIntent, "answer")                    )                    .addAction(                        R.drawable.common_google_signin_btn_icon_dark_focused,                        "Ignore",                        getPendingIntent(fullScreenIntent, "ignore")                    )                    .setOngoing(true)            val cons= ChatViewModel(application).getChat(userId)            if(cons == null){                val ref= FirebaseDatabase.getInstance().reference.child("Users")                ref.addValueEventListener(object : ValueEventListener {                    override fun onDataChange(snapshot: DataSnapshot) {                        builder.setContentText(snapshot.child(userId).child("number").value.toString())                    }                    override fun onCancelled(error: DatabaseError) {                        TODO("Not yet implemented")                    }                })            }            else{                if(cons.name==""){                    builder.setContentText(cons.number)                }                else{                    builder.setContentText(cons.name)                }            }            return builder.build()        }    }    fun cancelNotification() {        val nMgr = getSystemService(NOTIFICATION_SERVICE) as NotificationManager        nMgr?.cancel(1)    }    inner class SinchCallListener : CallListener {        override fun onCallEnded(call: Call) {            cancelNotification()            if (audioPlayer != null && audioPlayer!!.isPlayedRingtone()) {                audioPlayer!!.stopRingtone()            }        }        override fun onCallEstablished(call: Call) {            Log.d(TAG, "Call established")            if (audioPlayer != null && audioPlayer!!.isPlayedRingtone()) {                audioPlayer!!.stopRingtone()            }        }        override fun onCallProgressing(call: Call) {            Log.d(TAG, "Call progressing")        }        override fun onShouldSendPushNotification(call: Call, pushPairs: List<PushPair>) {            // no need to implement for managed push        }    }    companion object {        private val APP_KEY = "144a64d5-4b85-45a4-9b67-e7e8d5bca164"        private val APP_SECRET = "EHXpXse6cU2qf6NVFGXmpA=="        private val ENVIRONMENT = "clientapi.sinch.com"        const val LOCATION = "LOCATION"        const val CALL_ID = "CALL_ID"        val TAG = SinchService::class.java.simpleName    }}